import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const ENV_FILE_NAME = '.env'
const TEMPLATE_FILE_NAME = '.env.template'
const OUTPUT_FILE_NAME = 'env.generated.ts'
const __filename = fileURLToPath(import.meta.url)

function parseEnvFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf8')
  const envNames = []
  const lines = content.split('\n')

  for (const line of lines) {
    const trimmedLine = line.trim()
    if (trimmedLine.length === 0 || trimmedLine.startsWith('#')) {
      continue
    }

    const match = trimmedLine.match(/^([^=]+)=/)
    if (match && match[1]) {
      const key = match[1].trim()
      if (key.length > 0) {
        envNames.push(key)
      }
    }
  }

  return envNames
}

function parseEnvFileWithValues(filePath) {
  const content = fs.readFileSync(filePath, 'utf8')
  const envMap = new Map()
  const lines = content.split('\n')

  for (const line of lines) {
    const trimmedLine = line.trim()
    if (trimmedLine.length === 0 || trimmedLine.startsWith('#')) {
      continue
    }

    const match = trimmedLine.match(/^([^=]+)=(.*)$/)
    if (match && match[1]) {
      const key = match[1].trim()
      const value = match[2] || ''
      if (key.length > 0) {
        envMap.set(key, value)
      }
    }
  }

  return envMap
}

function generateEnvTypes() {
  const targetAppPath = process.argv[2]

  if (!targetAppPath) {
    console.error(
      'Error: Target application path (e.g., ./apps/api) must be provided as an argument.'
    )
    process.exit(1)
  }

  const envPath = path.join(targetAppPath, ENV_FILE_NAME)
  const templatePath = path.join(targetAppPath, TEMPLATE_FILE_NAME)

  const OUTPUT_DIR = path.join(targetAppPath, 'src/constants')
  const OUTPUT_PATH = path.join(OUTPUT_DIR, OUTPUT_FILE_NAME)

  if (!fs.existsSync(envPath)) {
    console.error(`Error: .env file not found at: ${envPath}`)
    process.exit(1)
  }

  try {
    // Parse .env file
    const envNames = parseEnvFile(envPath)

    if (envNames.length === 0) {
      console.warn(`Warning: No variables found in file ${envPath}.`)
    }

    // Sync .env.template with .env, preserving example values
    let existingTemplateMap = new Map()
    let existingTemplateVars = []

    if (fs.existsSync(templatePath)) {
      existingTemplateMap = parseEnvFileWithValues(templatePath)
      existingTemplateVars = Array.from(existingTemplateMap.keys())
    }

    const newVars = envNames.filter(
      (name) => !existingTemplateVars.includes(name)
    )

    const removedVars = existingTemplateVars.filter(
      (name) => !envNames.includes(name)
    )

    // Regenerate .env.template, preserving existing example values
    let templateContent =
      envNames
        .map((varName) => {
          const existingValue = existingTemplateMap.get(varName)
          if (existingValue !== undefined) {
            // Preserve existing value (example)
            return `${varName}=${existingValue}`
          } else {
            // New variable, add without value
            return `${varName}=`
          }
        })
        .join('\n') + '\n'

    fs.writeFileSync(templatePath, templateContent, 'utf8')

    if (newVars.length > 0) {
      console.log(
        `âœ… Added ${newVars.length} new variable(s) to ${TEMPLATE_FILE_NAME}: ${newVars.join(', ')}`
      )
    }

    if (removedVars.length > 0) {
      console.log(
        `ðŸ—‘ï¸  Removed ${removedVars.length} variable(s) from ${TEMPLATE_FILE_NAME}: ${removedVars.join(', ')}`
      )
    }

    if (newVars.length === 0 && removedVars.length === 0) {
      console.log(
        `â„¹ï¸  ${TEMPLATE_FILE_NAME} is already in sync with ${ENV_FILE_NAME}`
      )
    }

    // Generate TypeScript types
    let typeDefinition = `export type EnvironmentVariables = {
`
    let envNamesArray = `export const ENV_NAMES = [
`

    envNames.forEach((name) => {
      typeDefinition += `  ${name}: string
`
      envNamesArray += `  '${name}',
`
    })

    typeDefinition += `}\n`
    envNamesArray += `] as const\n`

    const generatedCode = `// This file was automatically generated by ${path.basename(__filename)} based on ${ENV_FILE_NAME}.

${typeDefinition}
${envNamesArray}
`

    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true })
      console.log(`Created directory: ${OUTPUT_DIR}`)
    }

    fs.writeFileSync(OUTPUT_PATH, generatedCode, 'utf8')

    console.log(
      `âœ… Successfully generated environment types in file: ${OUTPUT_PATH}`
    )
  } catch (error) {
    console.error(`Error processing files:`, error)
    process.exit(1)
  }
}

generateEnvTypes()
